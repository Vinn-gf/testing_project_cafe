id_user 2 : 25, 4, 17

id_user 4 : 1, 4, 7, 9

id_user 6 : 4, 5, 23, 34

id_user 3 : 23, 2, 6, 24, 35, 64

id_user 5 : 10, 36, 54, 48, 4

25, 4, 17, 1, 7, 9, 5, 23, 34, 2, 6, 24, 35, 10, 36, 54, 48


user 2 
composite-rating	: 5, 1, 9, 7, 34
rating			: 64, 10, 24, 9, 6, 54

user 3 
composite-rating	: 5, 34
rating			: 10, 5, 1, 17, 4, 9

user 4
composite-rating	: 17, 5, 25
rating			: 64, 10, 24, 17, 54, 35

user 5
composite-rating	: 17, 5, 7
rating			: 

user 6
composite-rating	: 
rating			: 

user 7
composite-rating	: 64, 24, 35, 34, 6, 2
rating			: 64, 24, 10, 35, 1, 6


# ── 1) Install & import ───────────────────────────────────────────────────────────
!pip install pandas requests scikit-learn tabulate --quiet

import requests
import pandas as pd
import numpy as np
import json
from sklearn.neighbors import NearestNeighbors
from tabulate import tabulate
from collections import defaultdict

# ── 2) Konfigurasi API & session ───────────────────────────────────────────────────
BASE = "https://775d-140-213-10-166.ngrok-free.app/"
session = requests.Session()
session.headers.update({"ngrok-skip-browser-warning": "true"})

# ── 3) Helper untuk fetch ─────────────────────────────────────────────────────────
def fetch_all_user_ids():
    r = session.get(f"{BASE}/api/users"); r.raise_for_status()
    return [int(u["id_user"]) for u in r.json()]

def fetch_visited(user_id):
    r = session.get(f"{BASE}/api/visited/{user_id}"); r.raise_for_status()
    data = r.json()
    if isinstance(data, dict):
        return data.get("visited_cafes", [])
    return data if isinstance(data, list) else []

def fetch_user(user_id):
    r = session.get(f"{BASE}/api/users/{user_id}"); r.raise_for_status()
    return r.json()

def fetch_cafe(cafe_id):
    r = session.get(f"{BASE}/api/cafe/{cafe_id}"); r.raise_for_status()
    return r.json()

# ── 4) Build user–item matrix dari menu_yang_disukai ───────────────────────────────
records = []
for uid in fetch_all_user_ids():
    u = fetch_user(uid)
    raw = u.get("menu_yang_disukai") or "[]"
    try:
        favs = json.loads(raw) if isinstance(raw, str) else raw
    except:
        favs = []
    for m in favs if isinstance(favs, list) else []:
        if isinstance(m, dict) and "harga" in m and "id_cafe" in m:
            try:
                price = int(str(m["harga"]).replace(".", ""))
                cid   = int(m["id_cafe"])
                records.append({"user_id": uid, "cafe_id": cid, "harga": price})
            except:
                pass

df_menu = pd.DataFrame(records)
if df_menu.empty:
    mat = pd.DataFrame()
else:
    mat = df_menu.pivot_table(index="user_id", columns="cafe_id", values="harga", fill_value=0)

# ── 5) Compute adjusted cosine similarity + KNN ───────────────────────────────────
if not mat.empty and mat.shape[0] > 1:
    X = mat.sub(mat.mean(axis=1), axis=0)
    num = X.dot(X.T)
    norm = np.sqrt((X**2).sum(axis=1).to_numpy())
    den  = np.outer(norm, norm) + 1e-8
    sim_vals = np.divide(num.values, den, out=np.zeros_like(num.values), where=den>0)
    sim = pd.DataFrame(sim_vals.clip(-1,1), index=mat.index, columns=mat.index)
    dist_matrix = 1 - sim
    knn = NearestNeighbors(metric="precomputed", n_neighbors=min(5, len(dist_matrix)))
    knn.fit(dist_matrix.values)
else:
    sim = pd.DataFrame(); knn = None

# ── 6) Recommendation functions ────────────────────────────────────────────────────
def recommend_by_menu(user_id, K=6):
    if knn is None or user_id not in sim.index:
        return []
    n_nb = min(K+1, len(sim))
    dists, idxs = knn.kneighbors((1-sim).loc[[user_id]].values, n_neighbors=n_nb)
    neigh = sim.index[idxs[0][1:]]
    scores = {}
    for cid in mat.columns:
        if mat.loc[user_id, cid]==0:
            num_ = sum(sim.loc[user_id,u]*mat.loc[u,cid] for u in neigh)
            den_ = sum(abs(sim.loc[user_id,u]) for u in neigh)
            scores[cid] = num_/den_ if den_>0 else 0
    return sorted(scores, key=scores.get, reverse=True)[:K]

def recommend_by_visited(user_id, K=6):
    seq = [int(v["id_cafe"]) for v in fetch_visited(user_id) if isinstance(v,dict)]
    trans = defaultdict(list)
    for uid in fetch_all_user_ids():
        vs = [int(v["id_cafe"]) for v in fetch_visited(uid) if isinstance(v,dict)]
        for a,b in zip(vs,vs[1:]):
            trans[a].append(b)
    cands = []
    for a in seq:
        cands += trans.get(a,[])
    freq = pd.Series(cands).value_counts().index.tolist()
    return [c for c in freq if c not in seq][:K]

def get_topK(user_id, K=6):
    pool = list(dict.fromkeys(recommend_by_menu(user_id,K*2)+recommend_by_visited(user_id,K*2)))
    rows = []
    for cid in pool:
        info = fetch_cafe(cid)
        if isinstance(info,dict) and "nama_kafe" in info and "rating" in info:
            rows.append({"cafe_id":cid,"nama_kafe":info["nama_kafe"],"rating":info["rating"]})
    df = pd.DataFrame(rows)
    if not df.empty:
        df["rating"]=pd.to_numeric(df["rating"],errors="coerce").fillna(0)
        return df.sort_values("rating",ascending=False).head(K)
    return df

# ── 7) Next‐item evaluator (leave‐one‐out) ─────────────────────────────────────────
def recommend_next(user_id, history, K=6):
    trans = defaultdict(list)
    for uid in fetch_all_user_ids():
        seq = [int(v["id_cafe"]) for v in fetch_visited(uid) if isinstance(v,dict)]
        for a,b in zip(seq,seq[1:]):
            trans[a].append(b)
    last = history[-1]
    freq = pd.Series(trans.get(last,[])).value_counts().index.tolist()
    return [c for c in freq if c not in history][:K]

def evaluate_next(K=6):
    hits, mrrs = [], []
    for uid in fetch_all_user_ids():
        seq = [int(v["id_cafe"]) for v in fetch_visited(uid) if isinstance(v,dict)]
        if len(seq)<2: continue
        hist, test = seq[:-1], seq[-1]
        recs = recommend_next(uid,hist,K)
        hits.append(1 if test in recs else 0)
        if test in recs:
            rank = recs.index(test)+1; mrrs.append(1.0/rank)
        else:
            mrrs.append(0.0)
    return {"HitRate": np.mean(hits) if hits else 0.0,
            "MRR":     np.mean(mrrs) if mrrs else 0.0}

# ── 8) Main: Cetak rekomendasi + evaluasi ──────────────────────────────────────────
if __name__=="__main__":
    users = fetch_all_user_ids()
    if users:
        target = users[1]
        print(f"\nTop 6 rekomendasi untuk user {target}:")
        top6 = get_topK(target,6)
        if not top6.empty:
            print(tabulate(top6, headers="keys", tablefmt="github", showindex=False))
        else:
            print("Tidak ada rekomendasi.")

    print("\n=== Evaluasi Next‐Item (leave-one-out) ===")
    metrics = evaluate_next(6)
    for k,v in metrics.items():
        print(f"{k}: {v:.4f}")
